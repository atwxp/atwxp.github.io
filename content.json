[{"title":"微信小程序的尝试","date":"2017-04-26T07:26:09.000Z","path":"2017/04/26/wechat/","text":"因工作需求尝试开发了微信小程序，这里总结一下开发经验。 准备工作根据官方文档，我们首先要申请 AppId，跟着流程走就好了，因为是个人开发所以主体类型就选择个人。 接下来我们要下载 微信开发者工具，它用来创建、调试、发布小程序。 浏览一下官方文档，我们大概知道： 小程序的文件类型有四种： .wxml, .wxss, .js, .json 小程序的每个页面都要写在 app.json 中的 pages 字段内，且 pages 中的第一个页面是小程序的首页，格式为 路径＋页面，如 123456// app.json&quot;pages&quot;:[ &quot;pages/welcome/welcome&quot;, &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;], 每个页面都是由同路径下同名的四个不同后缀文件的组成，如 index 下有 index.js, index.wxml, index.wxss, index.json 整个程序不是跑在浏览器下，所以和 DOM 相关的事件没法使用 我们不能加载非自定义的页面，如跳转到 m.baidu.com 创建项目看完官方文档介绍后，就可以着手写个 Todo 了（Fork 别人修改的） 项目结构很简单，就只有一个页面： 这里把 todos 放在 localstorage 保存： 123save: function (data) &#123; wx.setStorageSync(STORAGE_TODO_KEY, data)&#125;, 不管是添加、删除、更改状态，操作的对象都是 Todos 这个数组，但是已经完成的 todo、没有完成的 todo 的个数都是和 Todos 相关联的 1234567filterDone: function (data = this.data.todos) &#123; return data.filter(todo =&gt; todo.done)&#125;,filterRemain: function (data = this.data.todos) &#123; return data.filter(todo =&gt; !todo.done)&#125;, 所以我们可以写个类似 vue 中 computed 的计算属性： 1234567computedTodoData: function (data) &#123; return &#123; todos: data, doneCount: this.filterDone(data).length, remainCount: this.filterRemain(data).length &#125;&#125;, 这样在执行如删除操作的时候，手动调用它就好了 12345678// 删除 todo itemremoveTodo: function (e) &#123; const index = e.currentTarget.dataset.index this.data.todos.splice(index, 1) this.setData(this.computedTodoData())&#125;, 发布项目完成后点击发布，就可以在开发者中心的 开发管理 找到 开发版本： 右侧点击 体验版 就可以发布为体验版，点击左下角就可以下载二维码进行扫码体验（即使后面再次修改再次发布，这个二维码也不会变） 然后在 用户身份 这里绑定需要的体验者： 不同1. rpxwxss 中的像素单位有 px, rpx, em... 其中 rpx 是在微信中定义的，即把手机屏幕分为750份 11rpx = screen.width / 750 拿 iphone6 来看， 1rpx = 0.5px 所以按照 iphone6 的设计稿，前端直接量取间距就可以使用，无需再进行换算 2. 组件微信定义了一系列组件，不能使用 HTML ，就使用来看 &lt;view&gt; 相当于 &lt;div&gt; &lt;p&gt;&lt;h1-h6&gt;&lt;span&gt;&lt;em&gt;... 相当于 &lt;text&gt; &lt;img&gt; 相当于 &lt;image&gt; … 3. 图片微信的 &lt;image&gt; 组件很好用，当我们要把一个图片按比例居中显示，HTML 的写法有点复杂： 1234567891011121314&lt;div class=\"wrapper\"&gt; &lt;div class=\"image\" style=\"background-image:url();\"&gt;&lt;/div&gt;.wrapper &#123; width: 100px; height: 0; padding-top: 100%;&#125;.image &#123; height: 0; padding-bottom: 100%; background-size: cover; background: top center;&#125; 在小程序中非常简单，魔法就是 mode 属性，设置为 aspectFill 就可以实现 background-size: cover 的效果： 1&lt;image mode=\"aspectFill\" src=\"&#123;&#123;img&#125;&#125;\"&gt;&lt;/image&gt; 有坑1. 开启环境不校验请求域名涉及到 wx.request() 的请求，开发的时候要勾选 开发环境不校验请求域名 不然 会请求失败 同时在手机预览调试的时候，需要打开手机上的调试工具 vConsole 2. 选择符官方给的选择器有类、ID、元素、::before/::after，但是在项目中 :nth-child, div + div 这些也是能用的，不知道会不有坑。。。 3. flex布局的坑写了个 例子 想实现这样的布局，使用了 flex，在微信上实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;view class=\"item\"&gt; &lt;image src=\"http://gw.alicdn.com/bao/uploaded/T1tKJKXqlcXXb1upjX.jpg\" mode=\"aspectFill\" class=\"image\"/&gt; &lt;view class=\"content\"&gt; &lt;text class=\"title\"&gt;helllohelllo,helllo,helllohelllo, helllohelllo,helllohelllo&lt;/text&gt; &lt;text class=\"desc\"&gt;fsfsfhelllo, helllohelllo, helllosdfs&lt;/text&gt; &lt;/view&gt;&lt;/view&gt;.item &#123; display: flex; padding: 12px 0;&#125;.image &#123; display: block; width: 25%; height: 160rpx; margin-right: 24rpx;&#125;.content &#123; flex: 1; line-height: 44rpx; font-size: 28rpx; // width: 20rpx; // overflow: hidden;&#125;.title &#123; display: block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: #00c;&#125;.desc &#123; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; color: #333;&#125; 显示如下： 左侧图片移出视口之外了，给 .content 加上宽度或者overflow: hidden 就好了 类似的问题在华为 UC 上也遇到过，需要给 flex item 定个宽度才可以 总结 移动端常见的 swiper, scroll 组件都已经内置了，填一下数据就好 数据必须使用 setData() 才能更新视图 页面布局基本使用 flex 搞定 一个列表的图片都是一次性加载的，没有性能优化？？ 还没有在多个真机实践到底还有多少坑 refer 小程序 - 官方文档 有用！关于微信小程序，那些开发文档没有告诉你的","tags":[{"name":"小程序","slug":"小程序","permalink":"https://atwxp.github.io/tags/小程序/"}]},{"title":"High Performance Mobile Web 101","date":"2017-04-19T04:12:37.000Z","path":"2017/04/19/high-performace-mobile-web-001/","text":"最近读了一本关于移动web开发性能优化方面的书 《High Performance Mobile Web》，这本书系统全面的介绍了性能优化的知识点，对我来说至少以后再回答 “你是怎么做性能优化的？” 这个问题，不会再简单罗列诸如懒加载图片、缓存 js/css、按需加载这些了，而是会从不同的方面系统的给出优化点。接下来的系列会对这本书做个简单的总结。 首先谈谈移动设备和PC之间的不同，包括硬件、网络、操作系统、引擎、webview等方面。 1、硬件条件现在市场上有很多种类型的移动设备，诸如平板（ipad…)、智能手机(iPhone, HTC…)、可穿戴设备（iwatch…)，对于web开发来说，这些移动设备和PC存在着很大的差别如分辨率，最直观的感受就是屏幕大小不一样，从性能优化的角度来说，不同点在于： CPU：核心工厂，解析下载执行的地方 内存：存储DOM树、图片、数据等 GPU：开启硬件加速渲染 GPU 内存：存储GPU渲染的层、图片、数据等 … 比如我自己的 Mac Pro 的内存是 8GB，iPhone 6s 的内存是 2GB 2、网络情况上网的途径无非就是 WiFi 或者数据流量，WiFi 可以是稳定的如家庭、工作网络，也可以是不稳定的如热点，流量的话更不用说了，偏僻的地方手机都没有信号。 平时我们谈到流量都是说 2G、3G、4G，这些名字是什么意思呢？你可能会猜到 G 就是 Generation 就是 代 的意思，所谓 2G 就是第二代XXX，3G 就是第三代XXX。嗯，事实也就是这样，除了这些名字之外，还有其他名字表示： GPRS (2G) EDGE (2.5G, 3G) UMTS (3G) WCDMA (3G) LTE (4G) … 虽然身边的人大都是 4G 用户，但是移动网络是不稳定的，看到是 4G 信号也不表示用的是 4G，很可能降到了 3G，更何况我这种之前一直使用 3G 的用户，在地铁上就没打开过网页。。。 PS：The State of LTE (November 2016) 可以看到全球 4G 的使用率 网络有带宽、延迟的特性，在移动开发中，我们是否也需要关注这些呢？ 带宽带宽固然也大越好，但是相比较我们传输的文本文件的大小，似乎也没有很大的影响，除非你要求实时传输，做视频音频流这些对带宽具有高要求的需求 延时计算机网络有一个概念：RTT(Round-Trip-Time)，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。不管怎么样延迟是避免不了的，这是因为手机连到网络上需要经过发射塔、运营商网关、服务器，然后取得数据之后再反向走一遍。 PS：书中提到 2G 下有 1s 的延时，4G 下有 180ms 的延时 radio rate手机使用无线电和发射塔通信，无线电的使用会消耗电量，所以操作系统会尽量减少它的使用，这意味着如果没有 App 使用网络，手机会把无线电状态从 active 切换为 idel，当有软件请求数据时，会重启无线电，这个过程也花费时间 PS：书中提到 3G 下这个时间可以达到 2.5s，4G 下通常少于 100ms 3、操作系统市场上主流的手机操作系统有 iOS, Android, Windows，平时开发我们只会考虑前两者。此外还有一些其他操作系统，比如 BlackBerry, Firefox OS, Symbian...，一般不考虑这些。 PC 上的话，主流的有 Windows, MacOS, Linux, Ubuntu...。 PC：相比较移动设备，PC开发的时候一般不会去判断系统类型 4、引擎引擎分为渲染引擎和 js 执行引擎。 4.1 渲染引擎渲染引擎（布局引擎）是用来下载、解析、渲染 HTML、CSS的，包括相关的内容如SVG、图片。 目前主流的操作系统如 iOS、Android... 等都是使用 webkit 渲染引擎。除了 webkit，还有其他的渲染引擎可供选择如 Blink, Trident, Gecko, Presto： webkit 是 Apple 基于 KHTML 创建并使用在 safari 中的一个开源项目，引擎中和渲染布局相关的代码叫做 WebCore。 blink 是 Google 基于 webkit 开发的，目前 chrome, opera 都在用 blink 引擎。 Trident 是 IE 专有的引擎，自从 windows 10 以后，微软又基于 Trident 重写了一个引擎 Edge Gecko 是 Mozilla 维护的开源引擎 Presto 是 opera 特有的引擎，自从 opera 12 后就切换为 blink 了 4.2 执行引擎执行引擎是一个解释执行代码、管理内存的运行时环境。有些引擎会包含 Just-In-Time(JIT) 编译有些则不会，那他们有什么差异？ 没有 JIT 编译的引擎会边执行 JS 代码边解释，而有 JIT 的会在执行之前编译为机器码，如果再次执行相同的代码无需再翻译直接执行机器码就好了。 javaScriptCoreJavaScriptCore 引擎是 WebKit 中默认的引擎，在早期阶段只有解释器来解释执行 JavaScript 代码，性能不是特别突出，后来经过优化产出了 Nitro，也正是 safari 浏览器所使用的 V8Google 开发的开源js引擎，V8在执行之前会把 js 代码编译为机器码从而提高效率，更进一步使用了内联缓存等优化性能。 V8 是 Google Chrome 浏览器内置的JavaScript 脚本引擎 同时也是 Node.js 支持的引擎 其他主流的 JS 引擎：IE 的 Chakra，Mozilla 的 monkey 系列 JaegerMonkey, IonMonkey... 5、web 平台web平台指的是我们编写的web应用在哪里被解析执行，换句话说就是指它的宿主环境。 平时开发最经常打交道的环境有两种：浏览器和app，一个是直接在浏览器地址栏打开能访问的到，一个是嵌套了app的外壳，即 webview 的方式 5.1 browser浏览器是最熟悉不过了，从PC开始就已经和它打交道了，Chrome、Firefox、Safari、IE。。。然而在移动设备上浏览器会更加五花八门 现在的手机都会自带一个浏览器出厂，称为 stock browser/preinstalled browser，这个浏览器的问题在于如果我们不更新手机系统，它就不会更新。 iOS 系统上的浏览器会比较简单点，它的预装浏览器是 safari，如果不是开发人员的话，很少会再去装其他的浏览器。如果装其他浏览器的话如 chrome, firefox, uc...，其实和 safari 都是使用一样的引擎，这是因为 iOS 系统的封闭性，第三方浏览器只能优化功能、定制UI等，所以整体上 iOS 上的 bug 会比较简单一致 Android 就不一样了，它是一个开源的操作系统，4.3 之前使用的是 webkit 的 webview，4.4 之后就转为基于 chromium 的 webview 了，也就是使用 blink/v8 渲染了。 因为 Android 自带的浏览器性能并不好，就导致各个厂商、浏览器厂商开发自己的浏览器，有的会使用 webkit 有的又使用 chromium，这就导致渲染会存在差异，修改了一个手机的问题，另一个手机可能还存在问题。 5.2 webviewwebview 是一个类似于按钮、输入框等的原生控件，它允许原生 App 包含并执行 web content，webview 可以使用整个屏幕或者一部分。webview 能做些什么？ 执行 js 代码 显示富文本内容 创建完整的用户界面 创建一个 in-app browser 创建一个 pseudo-browser …. in-app browservs pseudi browser什么是 in-app browser ？有些原生App想展示一个页面，但是并不希望你离开App，就在 app 内部提供了一个渲染环境。比如在 evernote 内打开一个链接，并没有调用 safari 浏览器 pseudo-browser 是一个被认为是浏览器的原生应用，但是它没有自己的渲染、执行引擎，使用的是系统原生的 web view。从用户的角度来说它是个浏览器，从开发者角度来说，它就是一个具有特殊 UI 的 webview。iOS Chrome 就是这样一个 pseudo-browser 他俩的区别在于 in-app browser 场景下的 app 并不是一个浏览器，你不能说evernote是个浏览器，即便它在app内部打开了一个页面 iOSiOS 8 之后，有两个 webview 可以用：UIWebView / WKWebView AndroidAndroid 使用的是基于 webkit 的 webview，Android 2.x 性能非常慢，虽然在 4.0 - 4.3 有所好转，但是在性能兼容性上并没有显著的提升。所以很多厂商都决定使用新版本的 webkit 或者 chromium 替换默认的 webview ，这就导致每个设备、操作系统对应的 webkit/chromium 的版本可能不一致 在 Android 4.4 之后，Google 决定使用 chromium。在 Android 5.0 之后，基于 chromium 39 版本的 webview 可以自动从 Google Play Store 更新，意味着用户不必手动更新系统就能体验最新webview的特性了 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"性能优化","slug":"性能优化","permalink":"https://atwxp.github.io/tags/性能优化/"}]},{"title":"弹性布局的实践","date":"2017-04-11T04:05:21.000Z","path":"2017/04/11/flex-study/","text":"如下图所示的布局，红球区域有33个球，篮球区域有16个球，要求自适应页面且最边上的球必须紧靠区域边缘 HTML 结构 12345&lt;div class=\"ball-list\"&gt;&lt;i class=\"ball\"&gt;&lt;/i&gt;&lt;i class=\"ball\"&gt;&lt;/i&gt;...&lt;/div&gt; 1、float/inline-block 布局123456.ball &#123; display: inline-block; width: 28px; height: 28px; margin-right: 8px;&#125; 右侧会存在空隙，因为一行放不下的时候，浏览器就会折行显示 2、flex 布局这种复杂又要求自适应宽度的布局，用 flex 再好不过了 123456789.ball-list &#123; display: flex; flex-wrap: wrap; justify-content: space-between; .ball &#123; // 兼容旧浏览器，子元素必须是块元素 display: block; &#125;&#125; 效果如下： 看样子不错的说，但是最后一行不尽人意 3、flex + margin: auto 布局12345&amp;.flexauto &#123; .ball:last-child &#123; margin-right: auto; &#125; &#125; 效果不错，但是不够好 4、flex + js尝试了前面几种方法，都不尽人意，看来纯粹使用 css 是行不通的，那只能使用 js 计算空出的占位符个数，手动填满这个区域 1234567891011121314151617181920var width = parseFloat(window.getComputedStyle(ballList).width);// 33 是球的个数// 8 是 margin-right// 38 是球的宽度var cols = Math.floor((width + 8) / 38);var remainCols = cols - 33 % cols;var fragment = document.createDocumentFragment();for (var i = 0; i &lt; remainCols; i++) &#123; var itag = document.createElement('i'); itag.className = 'ball'; fragment.appendChild(itag);&#125; ballList.appendChild(fragment); 大功告成 5、Demo戳 这里 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"对 webpack hash 的理解","date":"2017-04-10T11:45:31.000Z","path":"2017/04/10/webpack-hash/","text":"1、hash &amp;&amp; chunkhashwebpack 提供了两种方式实现缓存 一种是为所有的 chunks 打上同样的 hash ，即编译 hash 一种是根据每个 chunk 的内容打上各自的 hash，即 chunkhash 123456output: &#123; path: 'output', filename: '[name].[hash].js' // or // filename: '[name].[chunkhash:4].js'&#125; 下面是很常见的 webpack 配置： 对 js 的 [chunkhash] 由 webpack 计算 图片/字体的 [hash] 由 file-loader 计算 提取的 CSS 的 [contenthash] 由 extract-text-webpack-plugin 123456789101112131415161718192021222324252627// productionoutput: &#123; filename: '[name].[chunkhash:8].js'&#125;,module: &#123; rules: [ &#123; test: /\\.(jpe?g|png|gif|svg)$/i, loader: 'url-loader', options: &#123; limit: 1000, name: 'assets/imgs/[name].[hash:8].[ext]' &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)$/i, loader: 'url-loader', options: &#123; limit: 10000, name: 'assets/fonts/[name].[hash:8].[ext]' &#125; &#125; ]&#125;,plugins: [ new ExtractTextPlugin('[name].[contenthash:8].css')] 2、 不稳定的 chunkhash编译 hash 是很稳定可信赖的，但是不能做持久化缓存；chunkhash 看样子是根据 chunk 内容改变 hash 的，但是也不一定可信 比如我们加上 extract-text-webpack-plugin 抽取 css 出来： 12345678910111213141516171819202122/src |- pageA.js |- pageA.css// pageA.jsrequire('./a.css');// webpack.config.jsoutput: &#123; filename: 'bundle.[chunkhash:4].js'&#125;,module: &#123; loaders: [&#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader') &#125;]&#125;, plugins: [ new ExtractTextPlugin('[name].[contenthash:8].css')] 修改 pageA.css 前后构建结果如下： pageA.js 这个 chunk 的输出在 webpack 看来是包括 css 文件的，只不过被我们抽取出来罢了，所以改 css 也就改了这个 chunk 的内容 3、 自定义 hash解决这个问题可以使用 webpack-md5-hash：排序 chunk 的所有依赖模块，并将这些排序后的模块源代码拼接，最后用 MD5 拼接后内容的 chunkhash PS：为什么要排序呢？因为比如一个模块 b 先后引入了 c, d，后来我们换了位置变成了 d, c 实际内容没有变所以 hash 也不应该改变的 123456789101112131415161718function compareMod(modA, modB) &#123; var modAPath = getModFilePath(modA); var modBPath = getModFilePath(modB); return modAPath &gt; modBPath ? 1 : modAPath &lt; modBPath ? -1 : 0;&#125;function getModSrc(mod) &#123; return mod._source &amp;&amp; mod._source._value || '';&#125;compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('chunk-hash', function (chunk, chunkHash) &#123; var source = chunk.modules.sort(compareMod).map(getModSrc).join(''); chunkHash.digest = function() &#123; return md5(source); &#125;; &#125;);&#125;); 这样就能解决前面修改 ExtractTextPlugin 的问题，但是依然存在问题 4、发布版本不一致有 a.js, b.js, index.js 如下： 12345678910111213// a.jsrequire('./index')var a = 1424;// b.jsrequire('./index')// webpack.config.jsnew webpack.optimize.CommonsChunkPlugin(&#123; name: 'common', minChunks: 2, chunks: ['a', 'b'],&#125;) 第一次编译： 修改 a.js 再次编译： 可以看见 common.xx.js 也跟着改变了，但是实际上我们仅仅修改了 a.js 不应该 common.js 也改变了才对 打开它的文件，发现这一段不一样： 1234script.src = __webpack_require__.p + \"\" + chunkId + \".\" + &#123;\"0\":\"81a79c6cc1fd236fb9ae\",\"1\":\"6a749561f8eb4005a925\"&#125;[chunkId] + \".js\";// 修改后script.src = __webpack_require__.p + \"\" + chunkId + \".\" + &#123;\"0\":\"81a79c6cc1fd236fb9ae\",\"1\":\"9ce6f42793d52c747c1a\"&#125;[chunkId] + \".js\"; 这个可以在 webpack 源码中找到原因，为什么 common.xx.js 的 hash 也发生变化了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// compilation.jsfor (i = 0; i &lt; chunks.length; i++) &#123; chunk = chunks[i]; var chunkHash = require(\"crypto\").createHash(hashFunction); // 根据chunk内容生成 chunkhash chunk.updateHash(chunkHash); // 这两句话用来生成要加密的信息 // 对于入口文件，走的是 chunkTemplate // 对抽取的公共文件如上文的 common.js, 走的是 mainTemplate if (chunk.entry) &#123; this.mainTemplate.updateHashForChunk(chunkHash, chunk); &#125; else &#123; this.chunkTemplate.updateHashForChunk(chunkHash); &#125; // webpack-md5-plugin 就是在 chunk-hash 触发的 this.applyPlugins(\"chunk-hash\", chunk, chunkHash); chunk.hash = chunkHash.digest(hashDigest); hash.update(chunk.hash);&#125;mainTemplate.plugin(\"hash-for-chunk\", function(hash, chunk) &#123; var outputOptions = this.outputOptions; var chunkFilename = outputOptions.chunkFilename || outputOptions.filename; // 这里会输出chunk、chunkhash对应的关系，拿上文的例子来说： // getChunkMaps() 得到一个对象 // &#123; // hash: &#123; // 0: 81a79c6cc1fd236fb9ae, // 1: 9ce6f42793d52c747c1a // &#125;, // name: &#123; // 0: 'a', // 1: 'b' // &#125; // &#125; // 因为我们修改了 a.js 内容发生变化，所以 hash 发生变化，从而上面的对象发生变化，所以 common.js 内容改变 hash 也因此变化 if(REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) hash.update(JSON.stringify(chunk.getChunkMaps(true, true).hash)); if(REGEXP_NAME_FOR_TEST.test(chunkFilename)) hash.update(JSON.stringify(chunk.getChunkMaps(true, true).name));&#125;); 通过这个源码可以知道在生成 chunkhash 的过程中，common.js 依赖 chunk 的 hash 值，这里的例子就是 a.js, b.js，因为修改了 a.js 导致其 chunkhash 变化，从而导致 common.js 内容变化从而其 hash 变化，但是 common.js 的本质内容并没有发生变化 在使用前面的自定义 hash 插件重复上述操作之后，效果如下： 看样子 hash 是没有变化了，但是当我们打开 common.js 会发现内容是发生变化的： 但我们的 chunkhash 并没有改变，这就导致 common.js 可能不能上传到线上，导致线上的 common.js 版本依然是旧的，这样就会出错 5、解决方法6、调试 webpack 下载 webstorm 全局/项目安装 npm install webpack-webstorm-debugger-script -g/--save-dev 配置 webstorm refer 你用 webpack 1.x 输出的 hash 靠谱不 用 webpack 实现持久化缓存 webpack 源码分析 如何十倍提升你的 webpack 构建效率 long term caching webpack1 cache webpack2","tags":[{"name":"构建工具","slug":"构建工具","permalink":"https://atwxp.github.io/tags/构建工具/"}]},{"title":"反广告过滤","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/ad/","text":"dom 的类名中存在某些关键词会被一些浏览器（猎豹，qq，UC…）的广告过滤机制干掉 已知的会被过滤掉的关键字： banner ad poster flag block download na-download 包括 HTML 中的 &lt;img /&gt; 的资源路径可能也会被过滤了，有次我把图片命名为 ad.jpg 就被过滤了。。 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"CSS计数器的使用","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/css-counter/","text":"使用场景类似这样的列表，前面的序号可以使用 CSS Counter 来实现： 12345678.list &#123; counter-reset: index; .item::before &#123; counter-increment: index; content: counter(index); &#125;&#125; 如果不想对某个元素生成计数器，有两个方法： display: none 无法正常生成内容的伪元素 好处1、减少 HTML 结构，不用多写一个 span 等标签来包裹它2、在某些情况下，涉及动态删除、添加列表等情况下，那么列表顺序会被打乱，不能自动排序，需要在js中动态实现；如果使用 css 的话，我们只需要专心实现dom 的增删即可3、一般这种序号都属于样式修饰，能做到与 HTML 分离自然是很好的 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"DeepLink && Universal Link","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/deeplink/","text":"webapp 开发中最常见的一个需求就是在浏览器下尝试调起 App，在此总结通用的解决方案和原理。 1、Deep Link In the context of mobile apps, deep linking consists of using a URL to link to specific content within an app. In order for your app to respond to URL requests correctly you need to implement something called a URL scheme. You can specify the URL Scheme in your app and decide what content to display to the user once the link has been clicked on and the app opened. 1.1 URI SchemeAndroid 1.0 就已经有了 URI Scheme Deep Link，它允许开发者给他们的 APP 注册一个 URI，然后我们在页面内可以通过一个链接如 myapp:// 打开这个 app，如果没有安装会报 page not found 类似的错误或者没有任何反应 不足：这种方法在用户安装了 app 的情况下，体验很好，如果没有安装 app，则会弹出 页面未找到 的错误弹框或者 没有反应，所以可能需要我们对这种情况降级处理 1.2 Android Chrome IntentAndroid Chrome 25+ 以后不在支持前面所说的 uri scheme，必须使用它规定的 intent 字符串形式，参考 Chrome documentation 1intent://&lt;optional path&gt;#Intent;scheme=&lt;URI scheme&gt;;package=&lt;package&gt;;S.browser_fallback_url=&lt;optional encoded fallback URL&gt; 这种形式提供了更好的解决方案： Open app via URI scheme if installed Fall back to Play Store page if not installed [Optional] Specify a URL to fall back to, instead of Play Store if not installed 这就意味着对 Android chrome 25+ 不必考虑未安装 App 的情况 2、Deferred Deep LinkDeferred Deeplink 先判断用户是否已经安装了 App 应用，如果没有则先引导至 App 应用商店中下载App，不同点在于用户安装 App 的情况下，跳转到的是指定的内容页面 Deeplink中，有几个服务可以用：tune/branch/deepshare/LinkedMe/魔窗 3、Universal LinkAndroid 6.0 支持 app Link ，IOS 9 支持 Universal Link IOS 9 这样介绍 Universal Link ： 只要点击一个指向你网站的链接，就会直接跳到你的App的页面，无需通过Safari。如果设备上没有安装你的应用，则会在Safari中打开你的网址;除了其他调用openURL的App外，只有WKWebView、UIWebView、Safari内点击的才支持跳转。像邮件、信息也是可以的;这功能只支持iOS 9.0以上系统，更早的系统版本会直接在Safari打开链接 在 Android M(6.0) 之前，我们用的是 uri scheme ，这种方法会弹出一个框，询问用户选择哪个 App 或者提示 xx 想打开 xx，Google 在 Android M 上添加了自动验证的功能，避免了这个弹框，使用户直达想要的 App 3.1 为什么要这么做 Custom URL scheme 因为是自定义的协议，所以在没有安装 app 的情况下是无法直接打开的，而 universal links 本身是一个 HTTP/HTTPS 链接，所以有更好的兼容性 不同的 app 是可以定义相同的 ustom URL scheme 的，所以会存在抢占或冲突的问题，而 universal links 是从 server 查询由哪个 app 打开的，所以不存在上述问题 Universal links 支持从其他 app 的 MKWebView 或 UIWebView 中跳转到目标 app Universal links 本身可以被搜索引擎索引 3.2 怎么配置一般都是端配置，大致是 在 Web 服务器上传 apple-app-site-association 的 json 文件，且能通过 https 访问到 我们不用关心 3.3 Universal Links的配置检查App Search API Validation Tool 提供了验证 universal link 的工具，如果 Link to application 的状态是 passed 就对了 3.4 产品体验目前可以在网易新闻、糯米等很多地方看到这种技术，下图就是微信中打开网易新闻后的界面，可以看到左侧是“返回微信”右侧是 163.com（点击的话会在 safari 中打开 universal link 调起不成功情况下跳转的链接） 3.5 坑 universal link 仅在 safari/chrome 有效，测试在 IOS 9 UC/QQ/Chrome/Safari 都有效 复制 universal link 到地址栏是无效的 因为是和 App &amp; webapp 绑定的，所以 App 要有一个与之相关的 webapp(废话…) 在 a 标签写上了 target=&quot;_blank&quot; 也是无效的（测试在 chrome 无效，所以建议不加） Universal Links cannot be triggered via Javascript (in window.onload or via a .click() call on an &lt;a&gt; element), unless it is part of a user action. （待测试。。。） 从 iOS 9.2 开始，在相同的 domain 内 Universal Links 是不work的，必须要跨域才生效，实测只需要跨子域名即可，比如 m.domain.com 跳转 o.domain.com 是可以触发的(不大晓得…) Universal Links 可以由系统来做选择，在短信或其他应用中，长按选择打开方式，若选择 Safari 打开，则后续的跳转会默认跳 Safari 如前面的图所示，如果用户点击了右上角的 163.com 链接，那么再次进入页面触发 universal link 不会在去调起 App，stackoverflow 有回答： Note that if a Universal Link succeeds in opening your app and then you click through to Safari (by tapping your site in the top right corner of the nav bar in app), then iOS stops opening the app when you visit that URL. Then in Safari, you can pull down to reveal a banner at the top of the page with “Open”. I wasted a lot of time on this. Note that clicking through to the site =&gt; disabling UL seems path specific, based on the paths you specify in the apple-app-site-assocation file. So if you have separate routes, yoursite.com/a/ and yoursite.com/b/, if you click yoursite.com/a/ and it opens your app directly, you then have the option in the top right corner of the app to click through to yoursite.com/a/. If you do that, subsequent visits to yoursite.com/a/ will open in browser, not app. However, yoursite.com/b/ should be unaffected and still open your app directly. 更多的坑需要在具体实践中注意 4、项目中的实践a href/ location.href1&lt;a href=\"myapp://\"&gt;&lt;/a&gt; 微信、微博无论装没装 App 都打不开 没有装 App，某些浏览器会跳到错误页，某些则是点击没有反应（符合前面描述的 deeplink 的问题） 一种解决方法是设置一个延时：1234location.href = appUrl;setTimeout(function () &#123; location.href = h5Url;&#125;, 1000); 如果能打开 app，那就是成功；如果没有打开点击没有反应，会在 1s 后自动跳转到 h5Url 这么写还是有些问题，如果用户切到 App 之后，迅速的又回到了 h5 页面，我们认为用户的行为就是想在 h5 页面浏览，那么这时候还进行 h5Url 的跳转是不合理的，所以可以改进一下：1234567var t = +new Date();location.href = appUrl;setTimeout(function () &#123; if (+new Date() - t &lt; 600) &#123; location.href = h5url; &#125;&#125;, 500); PS：这个方法只解决了点击没有反应这个问题，跳到错误页的问题没有解决 iframe 另一种解决方法是通过 iframe 跳转123456789callIframe: function () &#123; var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.style.width = 0; iframe.style.height = 0; iframe.src = this.appUrl; document.body.appendChild(iframe);&#125; 经过测试： 没有装 App，大多数浏览器都会跳转到 h5Url；safari 会弹出 “页面未找到” 的框再跳转到 h5Url 装了 App，基本上都可以跳到 App；Android Chrome 调起不成功，符合前面所描述的 Android Chrome Intent 的情况，maybe 改成 intent 形式就好了； 已装 App，调起 App 成功后，浏览器也会同时加载一个 h5 页面 iframe 的方法算是解决了没有装 App 会跳到错误页的问题。 如何避免同时加载 h5 pageshow：页面显示时触发，在 load 事件之后触发。需要将该事件绑定到 window 上才会触发 pagehide：页面隐藏时触发 visibilitychange：页面隐藏没有在当前显示时触发，比如切换 tab，也会触发该事件 document.hidden： 当页面隐藏时，该值为 true，显示时为 false 12345678document.addEventListener('visibilitychange', function () &#123; var tag = document.hidden || document.webkitHidden; if (tag) &#123; &#125;&#125;, false);window.addEventListener('pagehide', function () &#123;&#125;, false); 然而不幸的是，不是所有浏览器都会支持这些事件，所以这个恐怕暂时避免不了。 IOS9的升级 IOS 9 开始不支持 iframe 调起，点击没有反应，需要改为 location.href 调起，同时还做了下面的升级： What happens now is that in iOS 9, Apple changed the ‘Open App’ modal from a Javascript blocking modal to a non-blocking modal. 所以和 IOS9- 表现不一样的是 XX 想打开 XX/页面未找到 的模态框不会阻塞 js 执行了。 如果没有安装 App，就会弹出 “页面未找到” 的框；无效的弹窗提示在用户体验上是不允许出现的，但是线上产品普遍存在这个弹框的问题无法解决；但是在 IOS9 中会发现如果用户不进行操作，会自动跳转到 h5Url 了 安装了 App，也会弹框提示 “XX 想打开 XX” （感觉 IOS9 就是把 iframe 换成了 location.href，之所以这样做是为了支持 universal link）如果用户不点弹窗的确认按钮，会发现页面会自动跳转到 h5Url 了 微信的坑 微信默认屏蔽了 App 的 Scheme 跳转，但是有些 App 是可以跳转的： 大众点评，小红书，BiliBili，京东等 豆瓣等(universal link) 参考 微信API－－WXAppExtendObject 5、测试 demoDemo Refer iOS 9.2 Update: The Fall of URI Schemes and the Rise of Universal Links iOS/Android 浏览器(h5)及微信中唤起本地APP End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"window.getComputedStyle","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/getComputedStyle/","text":"获取元素的样式通常使用 window.getComputedStyle，有一天我写成了 document.getComputedStyle，总感觉不对劲，网上一查还真这回事o(╯□╰)o，只不过不是这样写的，而是 document.defaultView.getComputedStyle window.getComputedStylewindow.getComputedStyle(elem, [pseudoElt]) 1、使用这个方法返回的结果和 elem.style 返回的是一样的，都是 CSSStyleDeclaration 对象 但是二者也有一些区别： 前者是只读的，可以获取元素所有的样式信息，在 chrome 下测试返回 293 个属性 后者不仅可读还可以写，只能获取元素 style 属性中的样式 2、获取伪元素 3、值的类型 通过 getComputedStyle() 返回的值是 resolved value，这个值通常和 CSS2.1 computed value 相同，但是对于一些属性如 width, height可能就和 used value 相同。 MDN上说有些浏览器获取不到元素过渡时候的样式，自测 chomre, FF 是可以的，不过使用的时候还是注意一下为好 During a CSS transition, getComputedStyle returns the original property value in Firefox, but the final property value in WebKit. 4、兼容性 移动端：IOS safari 4.3, android 3- 不支持伪元素 PC：IE8- 完全不支持 所以在移动端，只要不涉及伪元素和低版本，可以放心使用 getPropertyValue()返回指定样式属性的值，是 CSSStyleDeclaration 对象的方法，用这个的好处： 1、对于驼峰式的样式名，如 background-color，就可以直接写 window.getComputedStyle(div, null).backgroundColor; // equal div.style.getPropertyValue(&apos;background-color&apos;); 2、对于 float 这些特殊样式名，不用考虑浏览器使用 cssFloat, styleFloat 等 div.style.getPropertyValue(&apos;float&apos;); 综上，推荐使用这个获取样式 3、兼容性 IE9+，现代浏览器 支持 document.defaultView.getComputedStyle不必要的，因为 window.getComputedStyle() 已经存在了，干嘛还再多访问一层属性呢","tags":[{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"Image On Retina","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/image-on-retina/","text":"所谓“Retina”是一种显示技术，可以将把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。 —— 百度百科 1、device pixeldevice pixel/physical pixel，即 设备像素/物理像素。我们近距离观察显示器屏幕，可以看到很多个点紧紧排在一起，这些点就是物理像素点，每个点都有自己的颜色和亮度。 一般可以通过 screen.width/screen.height 获取设备像素（在 PC 上就是电脑屏幕大小，当然这个值我们不 care） 屏幕密度，即屏幕上存在的像素数量，通常用 PPI 来衡量，即 pixels per inch，每英寸的像素数。 拿 MX3 来说，分辨率 1800 * 1080，尺寸 5.1寸，它的 PPI： 12// 411ppiPPI = Math.sqrt(1080 * 1080 + 1800 * 1800) / 5.1; 2、 css pixelcss 像素是一个相对单位，浏览器用它来渲染页面内容。通常情况下，css像素被称为 device-independent pixels(DIPs)。 在一个标准显示密度下，1个css像素对应1个屏幕像素。这对应于 PC 端的开发，设计图是多少像素，开发的时候就写多少像素。但是在移动端，事情变得有些复杂，涉及到 devicePixelRatio 的概念。 3、 关系css pixel 用来实现页面布局，定义每个元素的位置大小，然后设备则把 css pixel 转为 device pixel。 如定义一个 200*300 的盒子，在普通屏下，显示大小为 200 * 300；但是在 retina 屏幕下(假设设备像素比是2)，保证同样的尺寸大小，retina 渲染的像素点就是普通屏的4倍即 400*600 4、devicePixelRatio前面提到了一个概念 设备像素比，定义如下： devicePixelRatio is the ratio between physical pixels and device-independent pixels (dips) on the device. - quirksmode window.devicePixelRatio 可以获取设备像素比，一般都比较靠谱。其他两个值 physical pixel、dips 就比较复杂了。 5、dips 给页面设置 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 读取 document.documentElement.clientWidth 大多浏览器获取到的是 layout viewport 的宽度，也是 dips 的大小 PS：IOS 下，screen.width 返回 dips 6、physic pixel 设置页面 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 分别读取 screen.width, window.innerWidth, document.documentElement.clientWidth 在 MX3 下测试，只有 screen.width 返回的是 physical pixel。 More about devicePixelRatio 这篇文章总结到： window.devicePixelRatio 基本上浏览器都支持，数据可靠 对于 IOS 设备，获取 scree.width 得到 dips， 然后乘上 window.devicePixelRatio 得到 physical pixel 对于安卓设备，读取 screen.width 得到 physical pixel，然后除以 window.devicePixelRatio 得到 dips 关于 devicePixelRatio 的用法，参考这篇 wiki 7、retina 屏幕下的图片适配Bitmap Pixels位图像素是栅格图像中最小的数据单位，每个像素包含着它的位置信息、颜色、透明度。 和分辨率无关，web上的图像都有一个抽象的大小，是通过 css 定义的，浏览器会根据 css 定义的大小渲染图片。 其实和前面的盒子说到的问题一样，如果我们定义一张图 200*300 大小，在 retina 下为了保持同等尺寸大小，因为 retina 相比普通屏多了一倍像素，就是说现在要用4倍的像素量填充图片的大小，但是因为位图像素不能被分割，这样就会取就近色进行填充，导致图片失真。 图片适配为了适应 retina 高清屏，我们需要一份 @2x 的图片，在 css 这样写：123456.icon &#123; width: 20px; height: 20px; background: url(example@2x.png) no-repeat 0 0; background-size: 20px 20px;&#125; 有时候我们会需要适配不同设备像素比，就要用到 media query 了 12345678910.icon &#123; width: 20px; height: 20px; background: url(example.png) no-repeat 0 0; background-size: 20px 20px;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3)&#123; background-image: url(example@3x.png);&#125; Refer Towards A Retina Web More about devicePixelRatio A tale of two viewports visual-viewport-vs-layout-viewport-on-mobile-devices End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"基础知识","slug":"基础知识","permalink":"https://atwxp.github.io/tags/基础知识/"}]},{"title":"meta 元素的使用","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/meta/","text":"meta 标签viewport设置布局视口为设备宽度，不允许用户缩放，在网页加载时隐藏地址栏与导航栏1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\" /&gt; width：layout viewport 的宽度 height：layout viewport 的高度 initial-scale：初始的缩放比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩放 minimal-ui：iOS 7.1 Safari 为 meta 标签新增 minimal-ui 属性，在网页加载时隐藏地址栏与导航栏 PS: iOS 8 中移除了 ‘minimal-ui’ format-detectioniPhone 下会自动将一连串数字转换为拨号超链接，email则会调起邮件系统，去掉自动识别：1234&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;&lt;meta name=\"format-detection\" content=\"email=no\"&gt;&lt;!-- or --&gt;&lt;meta name=\"format-detection\" content=\"telephone=no, email=no\"&gt; apple-touch-icon设置 apple-touch-icon 属性，在 safari 上可以使用 添加到主屏幕 将页面添加到主屏幕上，方便用户以后快速访问1&lt;link rel=\"apple-touch-icon\" sizes=\"120*120\" href=\"/your-icon.png\"/&gt; sizes 适配不同的设备，没有设置的话，默认大小为 60 * 60 180 * 180：iphone6@3x 76 * 76：ipad 2 and ipad mini (@1x) 120 * 120：iphone4, 5, 6@2x 152 * 152：ipad and ipad mni (@2x) 图标搜索的优先级如下: 没有和相应设备推荐尺寸一致的图标，优先使用比推荐尺寸大，但是最接近推荐尺寸的图标 如果没有比推荐尺寸大的图标， 选择尺寸最大的图标 如果link标签没有指定图标，则在根目录寻找以 apple-touch-icon... 为前缀命名的图标 PS：IOS7 开始设备图标的推荐尺寸变化了： default: 57 * 57 =&gt; 60 * 60 iphone retina: 114 * 114 =&gt; 120 * 120 ipad retina: 144 * 144 =&gt; 152 * 152 ipad with no retina: 72 * 72 =&gt; 76 * 76 总结下来：1234567891011121314151617181920212223242526&lt;!-- For Chrome for Android: --&gt;&lt;link rel=\"icon\" sizes=\"192x192\" href=\"touch-icon-192x192.png\"&gt;&lt;!-- For iPhone 6 Plus with @3× display: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"180x180\" href=\"apple-touch-icon-180x180-precomposed.png\"&gt;&lt;!-- For iPad with @2× display running iOS ≥ 7: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"152x152\" href=\"apple-touch-icon-152x152-precomposed.png\"&gt;&lt;!-- For iPad with @2× display running iOS ≤ 6: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"apple-touch-icon-144x144-precomposed.png\"&gt;&lt;!-- For iPhone with @2× display running iOS ≥ 7: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"120x120\" href=\"apple-touch-icon-120x120-precomposed.png\"&gt;&lt;!-- For iPhone with @2× display running iOS ≤ 6: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"apple-touch-icon-114x114-precomposed.png\"&gt;&lt;!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≥ 7: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"76x76\" href=\"apple-touch-icon-76x76-precomposed.png\"&gt;&lt;!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≤ 6: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"72x72\" href=\"apple-touch-icon-72x72-precomposed.png\"&gt;&lt;!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" href=\"apple-touch-icon-precomposed.png\"&gt;&lt;!-- 57×57px --&gt; 上面的代码我们使用了 app-touch-icon-precomposed 属性，和 app-touch-icon 的区别在于：前者添加的是设计原图，不带有高光渐变效果，后者则是会带有 IOS 统一的高光效果 PS：判断用户是否是“将网页添加到主屏后，再从主屏幕打开这个网页” 1navigator.standalone app-touch-startup-image前面我们成功的添加页面到主屏幕上，然后我们还可以设置 app-touch-startup-image，即一个类似 NativeApp 的启动画面。 1&lt;link rel=\"apple-touch-startup-image\" href=\"startup-image.png\" /&gt; iphone3, 4, 5, 6只支持竖屏模式，而 iPhone 6 Plus 支持横屏，iPad有横屏竖屏。 Apple 官方文档建议竖屏模式的 iPhone 3， 4 启动动画的大小 320 * 460，之所以少了 20px，我们很容易想到是 IOS 状态栏的高度大小。对于 retina 屏幕，我们需要准备 640 * 920 大小的图片。不同于 app-touch-icon，启动画面没有sizes属性。 1234567891011121314151617181920212223242526272829&lt;!-- iPhone --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 320px)\" href=\"apple-touch-startup-image-320x460.png\"&gt;&lt;!-- iPhone (Retina) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 320px) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-640x920.png\"&gt;&lt;!-- iPhone 5 (Retina) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 320px) and (device-width: 568px) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-640x1096.png\"&gt;&lt;!-- iPhone 6 (retina) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 375px) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-750x1294.png\"&gt;&lt;!-- iPhone 6+ (portrait )--&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 414px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)\" href=\"apple-touch-startup-image-1242x2148.png\"&gt;&lt;!-- iPhone 6+ (landscape) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 414px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)\" href=\"apple-touch-startup-image-1182x2208.png\"&gt;&lt;!-- iPad (portrait) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 768px) and (orientation: portrait)\" href=\"apple-touch-startup-image-768x1004.png\"&gt;&lt;!-- iPad (landscape) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 768px) and (orientation: landscape)\" href=\"apple-touch-startup-image-748x1024.png\"&gt;&lt;!-- iPad (Retina, portrait) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 768px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-1536x2008.png\"&gt;&lt;!-- iPad (Retina, landscape) --&gt;&lt;link rel=\"apple-touch-startup-image\" media=\"(device-width: 768px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)\" href=\"apple-touch-startup-image-1496x2048.png\"&gt; apple-mobile-web-app-capable删除默认的 IOS 工具栏和菜单栏式，即开启 webapp 全屏模式1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; PS：当页面添加到主屏幕后再点击进行启动时有效，从浏览器跳转或输入链接进入并没有此效果 apple-mobile-web-app-status-bar-style设置 IOS 系统状态栏风格123&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt;&lt;!-- or --&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; content 参数的值： default：默认值白色 black：黑色 black-translucent：半透明 如果设置为 default 或者 black，页面内容从状态栏底部开始；如果设置为 black-translucent，页面内容充满整个屏幕，所以页面内容会被状态栏遮挡。 PS：只有在 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;时生效 添加到主屏后的标题&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;百度糯米&quot;&gt; 其他1、IOS上长按链接或者图片会默认弹出系统菜单，-webkit-touch-callout 可以禁止这个菜单的弹出（菜单默认是开启的），安卓不起作用1234a,img &#123; -webkit-touch-callout: none;&#125; 2、禁止选择文本（如果没有选择文本需要，建议最好加上）1234567html,body &#123; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 3、避免屏幕旋转导致字体大小缩放123body &#123; -webkit-text-size-adjust: 100%;&#125; 4、更改IOS 可点击元素的高亮颜色：当透明度设为0，则会禁用此属性；当透明度设为1，元素在点击时不可见；除了iOS Safari，大部分 Android 手机也是支持的 123body &#123; -webkit-tap-highlight-color: rba(255, 255, 255, 0);&#125; 5、隐藏地址栏 123setTimeout(function ()&#123; window.scrollTo(0, 1);&#125;, 0); 6、开启电话、短信功能 12345678// 电话&lt;a href=\"tel:10086\"&gt;10086&lt;/a&gt;// 短信&lt;a href=\"sms:10086\"&gt;10086&lt;/a&gt;// 邮箱&lt;a href=\"mailto:example@gmai.com\"&gt;example@gmail.com&lt;/a&gt; 7、判断屏幕方向12345678910111213switch (window.orientation) &#123; case -90: case 90: alert('横屏:' + window.orientation) break case 0: case 180: alert('竖屏:' + window.orientation) break default: &#125; 8、关闭 IOS 输入框首字母大写 1&lt;input type=\"text\" autocapitalize=\"off\" /&gt; 9、关闭 IOS 输入自动修正 1&lt;input type=\"text\" autocorrect=\"off\" /&gt; 10、-webkit-appearance display an element using a platform-native styling based on the operating system’s theme. 1234567891011/* Partial list of available values in Gecko */-moz-appearance: none;-moz-appearance: button;-moz-appearance: checkbox;-moz-appearance: scrollbarbutton-up;/* Partial list of available values in WebKit/Blink */-webkit-appearance: none;-webkit-appearance: button;-webkit-appearance: checkbox;-webkit-appearance: scrollbarbutton-up; 通常我们使用 none 重置表单外观 11、修改 placeholder 文字颜色 123456789101112131415::-webkit-input-placeholder &#123; color: #f00;&#125;/* firefox 18- */:-moz-input-placeholder &#123; color: #f00;&#125;/* firefox 19+ */::-moz-placeholder &#123; color: #f00;&#125;/* ie 10+ */:-ms-input-placeholder &#123; color: #f00;&#125; Refer &lt;head&gt; Cheat Sheet specifying a webpage icon for web clip Meta Tags Everything you always wanted to know about touch icons ios-web-app-icons-and-startup-images/ WebApp化（二）apple-touch-startup-image 移动Web开发技巧汇总 what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone-4 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"基础知识","slug":"基础知识","permalink":"https://atwxp.github.io/tags/基础知识/"}]},{"title":"background-clip 的 bug","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/background-clip/","text":"同时设置 border-radius &amp; background &amp; border-color &amp; background-clip 在 Android 4.1.1 上有 bug123456789101112131415161718position: absolute;top: 50%;left: 50%;margin-top: -37px;margin-left: -37px;width: 66px;height: 66px;// border: 4px solid rgba(255, 255, 255, 0.5);border: 4px solid #f00;background: #fafafa;border-radius: 50%;-webkit-background-clip: content-box;background-clip: content-box;text-align: center;line-height: 1;z-index: 1; 设置 border 不是透明色，表现的和预期一样： 如果设置为透明色，就会这样： Refer the-backgound-clip-property-and-use-cases End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"响应式图片精灵实现","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/responsive-image/","text":"背景在优化图片的时候，有一个分享功能，点击会弹出分享浮层，里面有各类社交 logo 如 QQ，微信，微博等，这些 logo 图片都是各自加载的，现在希望能做一张精灵图减少 HTTP 请求，样式如下图： 遇到的问题就是怎么能自适应的设置图片大小以及位置 实现原理首先我们有一个放置背景图片的容器，通过 CSS 把它写成正方形1234567&lt;div class=&quot;sprite&quot;&gt;&lt;/div&gt;div.sprite &#123; width: 20%; height: 0; padding-bottom: 20%;&#125; 假设我们的精灵图是 1000*500px，左边是 500px 宽的第一张图，右边是第二张图，假设我们这样写： 1234div.sprite &#123; background-image: url(./sprite.png); background-size: 100%;&#125; 我们会发现这张图会自动缩放在容器里，不是我们想要的容器内只显示一张图的效果。 实际上我们希望显示这张精灵图的一半大小，那么我们可以设置 background-size: 200%，这句话会设置精灵图的宽度为两个容器宽度的大小，又因为精灵图本身的两张图宽度比例是 1:1 的，所以每个图的宽度都是容器宽度12345678910div.sprite &#123; width: 20%; height: 0; padding-bottom: 20%; background-image: url('./sprite.png'); background-size: 200%; &amp;:hover &#123; background-position: 100% 0; &#125;&#125; 响应式的关键是 使用百分比设置图片的位置 拿项目本身来说，每个 logo 容器都是正方形，精灵图是 4 * 2 的，且每个都是 198*198 即也是正方形，怎么实现呢？1234.logo &#123; background-image: url(./sms.png); background-size: 400% 200%;&#125; 水平宽度写 400% 即是容器宽度的 4 倍大小，精灵图本身宽度是4个logo，所以每个logo在宽度上刚好占满容器宽度；高度同理 微信、微博、空间、邮件这几个很好设置图片位置123456789101112.wx &#123; background-position: 0 0;&#125;.weibo &#123; background-position: 0 100%;&#125;.qzone &#123; background-position: 100% 0;&#125;.email &#123; background-position: 100% 100%;&#125; 那么中间的怎么设置位置呢？我是这么理解，既然每个 logo 和容器大小是一样的，位置又是通过百分比来设置，那么假设 w 是容器宽度，m 表示精灵图有 m 列，第一排第 n 列 logo 的位置：1percent * w * m - percent * w = (n - 1) * w 即设置第一个 logo 百分比是 0，第二个是 1/3 第三个是 2/3 第四个是 3/3 Refer responsive-background-image-sprites-css-tutorial End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"iscroll 的坑","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/iscroll/","text":"问题描述给 iscroll 的子元素绑定 click 事件，在 猎豹，chrome, UC 等失效 原因后来查阅 文档 发现已经提示我们了 options.click为了重写原生滚动条，iScroll 禁止了一些默认的浏览器行为，比如鼠标的点击。如果你想你的应用程序响应 click 事件，那么该设置次属性为 true 。请注意，建议使用自定义的 tap 事件来代替它（见下面）。默认属性：false options.tap设置此属性为 true，当滚动区域被点击或者触摸但并没有滚动时，可以让 iScroll 抛出一个自定义的tap事件。这是处理与可以点击元素之间的用户交互的建议方式。侦听 tap 事件和侦听标准事件的方式一致。示例如下：12element.addEventListener('tap', doSomething, false); \\\\ Native$('#element').on('tap', doSomething); \\\\ jQuery 你可以通过传递一个字符串来自定义事件名称。比如：tap: ‘myCustomTapEvent’在这个示例里你应该侦听名为myCustomTapEvent的事件。默认值：false 在源码中可以找到实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273_initEvents: function () &#123; ... // 注册 click if ( this.options.click ) &#123; eventType(this.wrapper, 'click', this, true); &#125; ... // 注册移动端事件 if ( utils.hasTouch &amp;&amp; !this.options.disableTouch ) &#123; eventType(this.wrapper, 'touchstart', this); eventType(target, 'touchmove', this); eventType(target, 'touchcancel', this); eventType(target, 'touchend', this); &#125; ...&#125;_start: function (e) &#123; ... // 在 touchstart 阻止浏览器触摸行为，且禁用页面滚动 // preventDefaultException: &#123; tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ &#125;, // 这里没有 `a` 标签，所以点击带有 `href` 的 `a` 标签也会失效 if ( this.options.preventDefault &amp;&amp; !utils.isBadAndroid &amp;&amp; !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) &#123; e.preventDefault(); &#125; ...&#125;_end: function (e) &#123; ... // we scrolled less than 10 pixels if ( !this.moved ) &#123; // 触发 tap 事件 if ( this.options.tap ) &#123; utils.tap(e, this.options.tap); &#125; // 开启 click，使用自定义事件派发 click if ( this.options.click ) &#123; utils.click(e); &#125; this._execEvent('scrollCancel'); return; &#125; ...&#125;// addEventListener() a special function called handleEvent to catch any eventshandleEvent: function (e) &#123; ... case 'touchstart': this._start(e); case 'click': if ( !e._constructed ) &#123; e.preventDefault(); e.stopPropagation(); &#125; break;&#125;// utils.click me.click = function (e) &#123; var target = e.target, ev; if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) &#123; ev = document.createEvent('MouseEvents'); ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null); ev._constructed = true; target.dispatchEvent(ev); &#125; &#125;; 配置方案1、开启 click 配置 12345myScroll = new IScroll('#wrapper', &#123; mouseWheel: true, click: true &#125;);document.document.querySelector('#wrapper').addEventListener('click', function () &#123;&#125;); 带有 href 的 a 可以点击 不会有 300ms 延迟，在 touchend 触发的 不会冒泡，被 e._constructed 禁用了 2、开启 tap 配置12345myScroll = new IScroll(&apos;#wrapper&apos;, &#123; mouseWheel: true, tap: true &#125;);document.document.querySelector(&apos;#wrapper&apos;).addEventListener(&apos;tap&apos;, function () &#123;&#125;); 带有 href 的 a 还是点击不了 3、和 zepto 使用 如果是使用 $(&#39;&#39;).on(&#39;click&#39;) 和 原生的 addEventListener 没有差别，这个时候需要开启 click: true 如果是使用 $(&#39;&#39;).on(&#39;tap&#39;)，配置 click: false, tap: false 就好了；如果配置了 tap 反而会触发两次 tap 事件 4、 fastclick 使用 配置 click: false, tap: false，某些安卓机（三星）绑定 click 还是点不了 配置 click: true，IOS 点击不了（双击好像可以），三星反而能点击了 5、 zepto, fastclick 使用 配置 click: false, tap: false，使用 $(&#39;&#39;).on(&#39;click&#39;) 在某些安卓机不能点，开启 click: true，IOS 反而不能点 配置 click: false, tap: false，使用 $(&#39;&#39;).on(&#39;tap&#39;) 好像没啥问题；如果配置了 tap: true 反而会触发两次 tap 事件 总结测试机型有限，也不知道还有哪些坑（使用了 fastlick 好晕）。综上，如果使用 iscroll 想要监听内部元素的点击事件： 无论有没有 fastclick，使用 zepto(&#39;&#39;).on(&#39;tap&#39;） 应该是保险的； 或者开启 tap: true 配合原生的 addEventListener(tap) End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"CSS Selector","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/selector/","text":"什么是选择符选择符决定它和文档树中的哪个元素相匹配，其实是模式匹配，这样它所定义的样式就能应用到那个元素上。 怎么写选择符可以简单到只有一个元素名，如 p {}，也可以复杂到很多选择符组合在一起，如 .header .title {}。那它是怎么定义的呢？CSS3 中定义： 选择符是一组或多组简单选择符通过连接符组合起来的 一组简单选择符就是多个简单选择符不是用连接符组合起来的 简单选择符就是最最基本的选择符，包含 通用选择符(*)、类型选择符(p, div...)、类(.header...)、伪类(:first-child...)、ID(#footer…)、属性选择符([attr]...) 连接符包含 space, +, &gt; , ~ CSS3 和 CSS 2.1 有什么不同1、对于简单选择符的定义不同CSS 2.1 定义简单选择符为一个类型或通用选择符后跟着0个或多个属性、ID、伪类选择符。 也就是说 p.name 在 CSS2 中是一个简单选择符，而在 CSS3 中则是两个简单选择符连接在一起的一个组 2、引入了更多的伪类选择符CSS3 引入了如 nth-child(), :nth-of-type(), :target(), :not()...等丰富的伪类选择符 3、伪元素的写法改为 ::把 CSS2 中 :first-line 的写法改为了 ::first-line，即把伪元素的 : 改为了 ::，应该是要和伪类进行区分 4、引入了新的连接符 ~这是一个通用兄弟选择符，可能是觉得 + 还不够用吧，只能选择直接相邻的兄弟 连接符分为三种：后代(space)、子元素(&gt;)、相邻兄弟(+)、通用兄弟(~)，例如下面的demo： 123456789101112131415161718192021p + em &#123; color: #f00;&#125;p ~ p &#123; color: #00f;&#125;div span &#123; background: #ccc;&#125;div &gt; span &#123; color: #0a0;&#125;&lt;div&gt; &lt;p&gt;hello paragraph &lt;span&gt;div span &#123;&#125; select me&lt;/span&gt;&lt;/p&gt; &lt;em&gt;p + em &#123;&#125; select me&lt;/em&gt; &lt;p&gt;p ~ p &#123;&#125; select me&lt;/p&gt; &lt;span&gt;div span &#123;&#125; and div &gt; span &#123;&#125; select me&lt;/span&gt;&lt;/div&gt; 相邻兄弟我常用来设置重复区块之间的间隔： 123.group + .group &#123; margin-top: 20px;&#125; 分类 类：.class ID：#id 通用选择符：* 类型选择符：p, div, section... 属性选择符：[attr], [attr=val], [attr=|val], [attr=~val], [attr=^val], [attr=$val], [attr=*val] 伪类 动态伪类 链接伪类：:link, :visited 用户交互：:hover, :active, :focus 目标：:target UI：:enabled, :disabled, :checked 结构化：:nth-child(), :nth-last-child(), :nth-of-type(), nth-last-of-type(), :only-child, :only-of-type, :empty... :not() 伪元素 ::first-line ::first-letter ::before/::after ::before/::after这两个伪元素功能非常强大，从 a single div这个页面就可见一斑。日常中用它画个三角形、放置一个背景图片都是很常见的： 123456p::before &#123; content: ''; width: 40px; height: 40px; background: url('');&#125; 个人很喜欢这俩，既不占用额外的 HTML 标签，又能写丰富的样式和动画 权重我们有这么多的选择符，那如果多个选择符都匹配同一个元素时，该应用哪个呢？规范定义了一组数值 abc 计算 ID 选择符 的个数，赋值给 a 计算 类、属性、伪类 选择符 的个数，赋值给 b 计算 类型、伪元素选择符 的个数，赋值给 c 忽略通用选择符 :not() 不计算，但它里面的选择符还是正常计算 下面的例子中 p#footer 的权重最大： * =&gt; 000 p =&gt; 001 p::before =&gt; 002 p#footer =&gt; 101 p.name =&gt; 011 这些是从选择符本身来看的，如果结合样式的来源（开发者、用户、浏览器）以及重要性 (!important)来看，那么一个元素最终的样式规则定义如下： 根据来源、重要性排序 浏览器默认样式 开发者定义的普通样式 用户定义的普通样式 用户定义的重要样式(!important) 开发者定义的重要样式(!important) 相同重要性、来源的再根据选择符本身的权重抉择，越具体权重越大 前面计算的结果都一样的话，后来者居上 从上面的定义可以看到虽然用户可以覆盖开发者样式，但是 !important 赋予了开发者更高的权利，从而可以提高页面易访问性，避免用户瞎写导致页面布局错乱 属性值的计算一旦用户代理解析完文档并构建了一个文档树，那么就需要为每个元素赋予其相应的属性值如 border, color 等。那么这个属性值是如何计算的呢？根据规范，最终的属性是通过下面4个步骤计算得到的： 规范规定的默认值或者在样式文件指定的值，specified value 转换为可以被用来继承的值，computed value 转换为绝对值如果必要的时候，used value 根据实际环境转换为实际值，actual value specified value 首先 UA 必须为每一个属性赋予一个值，这个值： 如果在样式文件中指定了，那么使用它 否则，如果这个属性是可以继承的且不是根元素，那么使用父元素的 `computed 否则，使用这个属性的初始值（由规范指定） 可以认为这一步是先要获取一个默认值（因为每个属性必须有值） computed value 由第一步得到的属性值，可能是绝对值也可能是相对值。 绝对值即不依赖其他值的值，例如 p{color: red，font-size: 14px;}，这些值不需要计算转换，所以在第二步成为为 computed value 对于相对值，例如 width: 20%，必须要有一个参考值(依赖布局才能决定)才可以被计算出来。 还有一些相对值em，如 {font-size: 16px;padding-top: 2em}，就直接转换为 {padding-top: 32px;}，不需要等到第三步 used value css 最终使用的值。computed value 是在不渲染文档最大程度处理的值。 但是有一些值只能在文档被确定布局之后才能决定。例如子元素的宽度设置为其包含块的 20% 等，那么子元素的宽度必须要等到包含块的宽度确定了才能确定。 所以 computed value 与 used value 的区别是： 前者是在页面展现之前，仅处理样式时就能得出的尽可能接近绝对的结果； 后者则是页面展示时，得出的绝对值。 actual value 原则上，used value 是可以被使用的，但是 UA 可能在一些环境中无法使用这个值，例如 UA 可能只允许渲染整数值的 border，这个时候就需要使用和 used value 接近的值。 这些有什么用？有一个例子是行高的继承，我们知道行高的设置有 数字、百分比、具体值，如果我们要设置一个页面所有内容都是行高为字体的2倍大小，比如：123456789body &#123; font-size: 12px; line-height: 2em; line-height: 200%; line-height: 2;&#125;&lt;body&gt; &lt;p&gt;font-size: 15px&lt;/p&gt;&lt;/body&gt; 哪个是正确的呢？答案是 line-height: 2，根据 规范： &lt;length&gt;The specified length is used in the calculation of the line box height. Negative values are illegal.&lt;number&gt;The used value of the property is this number multiplied by the element’s font size. Negative values are illegal. The computed value is the same as the specified value.&lt;percentage&gt;The computed value of the property is this percentage multiplied by the element’s computed font size. Negative values are illegal. Refer CSS2.1 Selector REC - W3C CSS3 Selector REC - W3C cascade REC - W3C generate text - W3C Visual formatting model details - W3C End.","tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://atwxp.github.io/tags/基础知识/"}]},{"title":"touchcancel的使用","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/touchcancel/","text":"通常我们常用的手势事件有 touchstart, touchmove, touchend，对 touchcancel 用之甚少，仅知道就是由于系统原因导致的手势中断而触发的事件。 在一个项目中我就用到了这个事件 touchcancel，有这么个需求：需要监听长按下载这个动作（浏览器默认支持长按下载，同时会弹出一个系统弹框） 很自然我们就想到了监听 touchstart/touchend，在 touchstart 记录起始点/时间，在 touchend 记录终止点/时间，满足长按要求则触发事件； 在实际测试过程中，有些浏览器并不触发 touchend 事件，这时候想到了 touchcancel ，猜测应该是这些浏览器弹出下载浮层属于系统中断 touch 事件，经测试猜想是正确的。 结论：某些浏览器下（UC/QQ...）系统弹层会阻止当前 touch 事件的发生，需要同时监听 touchend/touchcancel，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374define(function (require, exports, module) &#123; var util = require('util'); /** * init * * @param &#123;DOM&#125; wrapper longtap'wrapper * @param &#123;Object&#125; options options * @property &#123;number&#125; options.thresold 阈值 * @property &#123;number&#125; options.allowedTIme 允许时间 * @param &#123;Function&#125; callback 回调函数 */ var init = function (wrapper, options, callback) &#123; var settings = &#123; thresold: 5, allowedTime: 300 &#125;; if (!wrapper) &#123; return; &#125; if (typeof options === 'function') &#123; callback = options; options = &#123;&#125;; &#125; callback = callback || function () &#123;&#125;; util.extend(settings, options); var startX; var startY; var startTime; wrapper.addEventListener('touchstart', function (e) &#123; var touchobj = e.changedTouches[0]; startX = touchobj.pageX; startY = touchobj.pageY; startTime = +new Date(); &#125;, false); wrapper.addEventListener('touchend', function (e) &#123; e.stopPropagation(); e.preventDefault(); var elapsedTime = +new Date() - startTime; var touchobj = e.changedTouches[0]; var endX = touchobj.pageX; var endY = touchobj.pageY; if ( Math.abs(endX - startX) &lt; settings.thresold &amp;&amp; Math.abs(endY - startY) &lt; settings.thresold &amp;&amp; elapsedTime &gt; settings.allowedTime ) &#123; callback(); &#125; &#125;, false); wrapper.addEventListener('touchcancel', function () &#123; callback(); &#125;, false); &#125;; exports.init = init;&#125;); End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"touchend不触发bug","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/touched-not-trigger/","text":"给一个元素绑定 touchstart, touchmove, touchend, click 如果只是触摸一下这个元素，按理是只触发 touchstart touchend click，如果滚动的话，应该就是多了一个 touchmove 而已 但是安卓机的某些浏览器（如 UC）在滚动的时候不会触发 touchend（偶尔也会触发），touchmove 可能也只是触发一次，见 demo 解决方法： 在 touchstart 设置 e.preventDefault()，页面不能滚动，链接不能跳转，不会触发 click 事件 在 touchmove 设置 e.preventDefault()，页面不能滚动以及不能 pinch-room 参考 Touch_events - MDN Since calling preventDefault() on a touchstart or the first touchmove event of a series prevents the corresponding mouse events from firing, it’s common to call preventDefault() ontouchmove rather than touchstart. That way, mouse events can still fire and things like links will continue to work. 参考 Preventing the touch default The default of all actions is prevented when you return false (or call preventDefault()) ontouchstart. The touchmove event is trickier: only scroll and pinch-zoom are prevented when you return false on that event. Refer 如何修复移动浏览器上 touchend 事件不触发的bug End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"UA检测","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/ua/","text":"1、平台检测安卓1var android = ua.match(/(Android)\\s([\\d.]+)/); IOS1234var ios = ua.match(/iPhone|iPad|iPod/);var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);var ipod = ua.match(/(iPod).*OS\\s([\\d_]+)/);var iphone = !ipad &amp;&amp; ua.match(/(iPhone)\\sOS\\s([\\d_]+)/); 2、浏览器检测Chrome12// chrome for ios use CriOS/ instead of Version/var chrome = ua.match(/(Chrome)\\/([\\d.]+)/) || ua.match(/(CriOS)\\/([\\d.]+)/); Safari12var ios = ua.match(/iPhone|iPad|iPod/);var safari = ios &amp;&amp; ua.match(/Version\\/([\\d.]+)([^S]*(Safari)|[^M]*Mobile[^S]*(Safari))/); UC1var uc = ua.match(/(UCBrowser)\\/([\\d.]+)/); QQ1var qq = ua.match(/(MQQBrowser)\\/([\\d.]+)/) 微信1var wechat = ua.match(/(MicroMessenger)\\/([\\d._]+)/); QQIM12// QQ聊天工具内置的浏览器, 安卓既有 MQQBrowser又有 QQ/5.8.0，IOS只有 QQ/5.8.0var qqim = ua.match(/(QQ)\\/([\\d.]+)/) || ua.match(/(MQQBrowser)\\/([\\d.]+)/); 百度浏览器1var bdbox = ua.match(/baiduboxapp/); 手百1var baidubrowser = ua.match(/baidubrowser\\/([\\d\\.]*)/); End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"基础知识","slug":"基础知识","permalink":"https://atwxp.github.io/tags/基础知识/"}]},{"title":"iphone上click事件不冒泡到document","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/click/","text":"问题在一个带有 展开/收起 的列表里，使用了委托处理点击 查看更多 的逻辑，如下图： 代码如下： 123$(document).on('click', '.footer', function (e) &#123; &#125;); 这段代码在 iphone 上点开不了，安卓都是 OK 的。可以点一下 测试DEMO 体验一下 为什么呢从网上搜到几篇文章提到 API-jQuery 有对 click 使用的提示： On mobile iOS (iPhone, iPad and iPod Touch) the click event does not bubble to the document body for most elements and cannot be used with .live() without applying one of the following workarounds: Use natively clickable elements such as a or button, as both of these do bubble to document. Use .on() or .delegate() attached to an element below the level of document.body, since mobile iOS does bubble within the body. Apply the CSS style cursor:pointer to the element that needs to bubble clicks (or a parent including document.documentElement). Note however, this will disable copy\\paste on the element and cause it to be highlighted when touched. 简单来说就是： 手机端的 IOS（iPhone, iPad, iPod Touch) 上，对于大多数元素来说，click 事件不会冒泡到 document.body 这个元素上，而且如果不满足下面的条件之一，不能和 .live()/.on() 使用: 使用原生可以冒泡到 document 的元素，如 a，button 委托事件到 document.body 的子元素 给需要冒泡 click 的元素或者其父元素（包括 document.documentElement ）设置 cursor: pointer，但是这样做不能 复制/粘贴 该元素内容，并且点击元素会高亮显示 解决方法1234567&lt;div class=\"wrap\"&gt; &lt;div class=\"fold\"&gt;not A or button element, iphone 上 document委托失效&lt;/div&gt; &lt;div class=\"fold\" style=\"cursor:pointer\"&gt;set cursor: pointer&lt;/div&gt; &lt;a href=\"javascript:void(0);\" class=\"fold\"&gt;a element success&lt;/a&gt;&lt;/div&gt; 1、委托到目标元素的父元素 123$('.wrap').on('click', '.fold', function () &#123; alert('委托到目标元素的父元素, success！');&#125;); 没啥兼容问题 2、设置目标元素 cursor: pointer123$(document).on('click', '.fold', function (e) &#123; alert('cursor: pointer, success！');&#125;); iphone6 上测试，复制粘贴没有问题，点击存在高亮 3、给body的子元素写一个click事件 参考 这篇文章 在冒泡阶段，有一个节点处理了该事件，它就不会丢弃该事件，会继续往上冒，冒到body 然后document 然后window 123$(document.body.children[0]).on('click', function () &#123; alert('给body内其他元素绑定一个事件');&#125;); Demo点 这里，扫码如下， 总结对比以上三种解决方法，委托到目标元素的父元素 是最简单、没有兼容性问题的方法。 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"RSS Reader Chrome Extension","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/rss-reader-cx/","text":"写了个简单的 rss reader 扩展，用来订阅一些博客了解最新的技术进展。 1、实现的功能 支持添加订阅、导入已有的 OPML，导出 OPML，可以分享到微博、印象笔记、（微信todo） 可以配置每页文章数量，几天更新一次 使用客户端存储 localStorage 每次切换到新的 rss feed，都会先判断本地存储是否存在且是否过期，过期会重新更新 导入 OPML 不会立刻请求所有文章更新，而添加单个 feed 会立刻请求文章存储在本地 2、实现效果 3、怎么做的主要是用 vue + vuex + vue-router + vue-resource + webpack 搭建，chrome 扩展以及 rss 相关的知识 3.1 chrome extension首先每个扩展都必须有个 manifest.json 文件，它是扩展的入口，数据格式是 json，如：12345678910111213&#123; \"manifest_version\": 2, \"name\": \"RSS\", \"version\": \"2.0\", \"browser_action\": &#123; &#125;, \"background\": &#123; \"scripts\": [\"background.js\"], \"persistent\": false &#125;, \"permissions\": [\"*://*/*\", \"tabs\"], \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\"&#125; name, version, manifest_version 是必须的，manifest_version 目前来说是 2 当我们点击扩展图标的时候，希望打开一个新的 tab，可以通过 background 配置 1234// background.jschrome.browserAction.onClicked.addListener(function (tab) &#123; chrome.tabs.create(&#123;url: url&#125;)&#125;) 因为我们需要请求 feed url，所以会涉及到跨域，chrome 扩展允许指定 permissions 声明跨域请求，比如我们尝试请求 m.nuomi.com 可以配置 manifest.json 如下： 1\"permissions\": [\"*://*.nuomi.com/*\"] 3.2 atom/rss xml这俩的规范在 这里 解析一段字符串为 XML 主要用到了 new DOMParser()，然后根据 DOM 结构解析即可 3.3 vue路由路由设计很简单就三个： /add: 添加、导出、导入 feed /setting：设置每页文章数目、每几天更新 /feed/:id：feed的详情页 数据数据有两个，feedList 存储订阅的 feed 源数组，config 存储阅读器本身的配置 1234567const store = &#123; feedList: [], config: &#123; perPage: 5, expired: 1 &#125;&#125; actionaction 有四个：添加订阅源 ADD_FEED, 删除订阅源 DELETE_FEED, 更改配置 UPDATE_CONFIG，获取 FeedList 123456789101112131415export const addFeed = (&#123; commit &#125;, feed) =&gt; &#123; commit(types.ADD_FEED, Array.isArray(feed) ? feed : [feed])&#125;export const deleteFeed = (&#123; commit &#125;, id) =&gt; &#123; commit(types.DELETE_FEED, id)&#125;export const updateConfig = (&#123; commit &#125;, cfg) =&gt; &#123; commit(types.UPDATE_CONFIG, cfg)&#125;export const fetchFeedList = (&#123; commit &#125;, [ url, id ]) =&gt; &#123; commit(types.SET_FEEDLIST, rss)&#125; 3.4 其他webpack2 有很多规则都不太一样了，比如 loader 的配置，loaders 改为了 rules，loader名字不能简写要写上 xx-loader 12345678module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ]&#125; 比如 resolve 中 extensions 第一个元素不再是 &#39;&#39; 了，默认是 [&#39;.js&#39;, &#39;json&#39;]，模块的查找路径写成了 modules: [src_path, &#39;node_modules&#39;] 1234567resolve: &#123; modules: [SRC_PARH, 'node_modules'], alias: &#123; 'vue$': 'vue/dist/vue.common.js' &#125;, extensions: ['.js', '.json', '.vue']&#125;, 4、 总结学习了 vue 全家桶的使用，不懂的地方其文档也写的非常清楚，以后还要更深入的理解 End.","tags":[{"name":"chrome extension","slug":"chrome-extension","permalink":"https://atwxp.github.io/tags/chrome-extension/"}]},{"title":"UC下字体突然变大","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/uc-font-scale/","text":"项目中遇到了页面的字体在 UC 变大的问题，后来排查是一个地方的 font-size: 12px 导致的，临时方案就是换了字体大小解决了问题 后来其他同事又遇到了这个问题，这不得不重视起来，于是在 知乎 上找到了答案 uc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验 解决方法是在头部加上1&lt;meta name=\"wap-font-scale\" content=\"no\"&gt; 尝试了其他方法也是可以的，如改变字体大小，把样式表放在最后加载等 End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"开发经验","slug":"开发经验","permalink":"https://atwxp.github.io/tags/开发经验/"}]},{"title":"Media Query","date":"2017-04-10T03:39:49.000Z","path":"2017/04/10/media-query/","text":"一、Media TypeHTML4 和 CSS2 支持针对不同媒体类型（Media Type）定制不同的媒体样式。 在 HTML 中可以这样使用1&lt;link rel=\"stylesheet\" media=\"print\" href=\"print.css\" /&gt; 在样式表中可以这样写: 12345@media screen &#123; p &#123; color: #f00; &#125;&#125; 规范定义很多媒体类型，但是都支持的浏览器确是很少，不过大都会支持这两个类型：screen &amp; print 二、Media QueryMedia Query 在 Media Type的基础上添加了对CSS属性的判断，所以它实际上是一个逻辑表达式。 OR (media query list)媒体查询列表即包含着多个媒体查询条件，只要符合一条即返回 true，即逻辑或的处理逻辑。如果列表为空，相当于返回 true。123@media screen, print &#123; … &#125;@media all &#123; … &#125;@media &#123; … &#125; allall 关键字表示适用于所有媒体类型，如果不明确媒体类型的话默认就是 all12@media all and (device-width: 320px) &#123;&#125;@media (device-width: 320px) &#123;&#125; not/onlynot 用来指定某个的媒体查询条件，而 only 用来指定某种媒体查询条件，用来排除不支持媒体查询的浏览器12@media not screen &#123;&#125;@media only print &#123;&#125; 支持的属性 width：布局视口的宽度 height：布局视口的高度 device-width：设备的宽度 device-height：设备的高度 device-aspect-ratio：设备像素比 orientation：横屏(lanscape) 或者 竖屏(portrait) … PS：这里只列出经常使用的属性 列出来这些属性之后，我发现少了我们最经常使用的 device-pixel-ratio，但是文档也没有提到它，后来在 caniuse 发现 device-pixel-ratio 竟然标记为 older not standard device-pixel-ratio media query。。。写了那么久以为是 standard，太孤陋寡闻了~ Resolutionresolution描述设备的分辨率（像素密度），单位有 dpi &amp; dpcm以及后来新增的 dppi dpi：dot per inch dpcm：dot per centimeter dppi：dot per pixel 简单的说就是 resolution 定义了 1px || 1 inch || 1 cm CSS 像素包含了多少个 物理像素点。 例如 iphone retina 的设备像素比是 2，那么完整的写法是：123456789/* dpi */@media screen and (min-device-pixel-ratio: 2), (min-resolution: 192dpi)&#123;&#125;/* dppi */@media screen and (min-device-pixel-ratio: 2), (min-resolution: 2dppi) &#123;&#125; PS：1dppi = 96dpi 至于为什么 device-pixel-ratio 不添加到规范中，可以看看 这篇文章 三、兼容性Media Query Feature IE Chrome FireFox Safari Opera IOS Safari Android 9+ 4+ 3.5+ 3.1+ 10.1+ 3.2+ 2.1+ 从 上表 以及 caniuse 可以看出，除了 IE8- 之外，其他浏览器都是支持 Media Query的，真是非常赞！ Resolution Feature IE：IE9+ 支持，但是只支持 dpi Chrome：4 - 28 支持 device-pixel-ratio，28+支持 resolution 最小：-min-webkit-device-pixel-ratio 最大：-max-webkit-device-pixel-ratio Firefox：16- 支持 device-pixel-ratio，对于 resolution 只支持 dpi； 最小：min--moz-device-pixel-ratio 最大：max--moz-device-pixel-ratio safari：目前只支持 device-pixel-ratio，且要加 -webkit- opera：10.1 - 11.5 支持 device-pixel-ratio，12.1+开始支持 resolution webkit 下的 2 要写成 2/1，1 即要写成 1/1 android：2.3 - 4.3 支持 device-pixel-ratio，4.4+开始支持 resolution 所以，针对高像素密度的屏幕适配如下：12345678910@media only screen and (-webkit-min-device-pixel-ratio: 2), // webkit-base(safari, android) only screen and ( min--moz-device-pixel-ratio: 2), // firefox 16- only screen and ( -o-min-device-pixel-ratio: 2/1), // opera 11.5- only screen and ( min-device-pixel-ratio: 2), // for standard only screen and ( min-resolution: 192dpi), // IE9+ only screen and ( min-resolution: 2dppx) // dppi &#123; /* Retina-specific stuff here */ &#125; Refer Media Query W3C SPEC unprefix-webkit-device-pixel-ratio resolution-units retina-display-media-query iPhone iPad Media Query End.","tags":[{"name":"移动web开发","slug":"移动web开发","permalink":"https://atwxp.github.io/tags/移动web开发/"},{"name":"基础知识","slug":"基础知识","permalink":"https://atwxp.github.io/tags/基础知识/"}]}]